<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Identidade Digital</title>
  <style>
    html,body{
      margin:0; padding:0; width:100%; height:100%; background:#f2f2f2; font-family:sans-serif;
      -webkit-user-select:none; user-select:none; overscroll-behavior:contain;
    }

    .container{
      position:relative; display:flex; flex-direction:column; width:100%; height:100%; background:#fff;
    }

    .top-bar{
      display:flex; justify-content:space-between; align-items:center;
      padding:12px 16px; background:#e6f6ff; border-bottom:1px solid #ddd; flex-shrink:0;
    }

    .top-left{ display:flex; align-items:center; gap:8px; font-size:13px; color:#333; }
    .dot{ width:10px; height:10px; background:#27ae60; border-radius:50%; }
    .close{ color:red; font-size:20px; font-weight:bold; cursor:pointer; }
    .menu{ width:20px; height:14px; border-top:2px solid #333; border-bottom:2px solid #333; position:relative; }
    .menu::after{ content:""; position:absolute; top:5px; left:0; width:20px; border-top:2px solid #333; }

    /* central area: flexible and guaranteed to have real height */
    .rg-area{
      flex:1 1 auto; /* grow, shrink, basis */
      min-height:240px; /* safe minimum */
      position:relative;
      background:#000; /* background during load */
      display:flex; align-items:center; justify-content:center; overflow:hidden;
    }

    /* wrapper just centers; image positioned absolutely so we can control sizing precisely */
    .rg-wrapper{ position:relative; width:100%; height:100%; display:flex; align-items:center; justify-content:center; }

.rg-img {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%) rotate(90deg);
  transform-origin: center center;
  width: 100vh;         /* altura da tela vira largura da imagem rotacionada */
  height: auto;
  max-width: none;      /* remove limite que estava travando o tamanho */
  max-height: none;
  object-fit: contain;
  display: block;
}


    .footer{
      position:fixed; bottom:30px; left:0; width:100%;
      display:flex; justify-content:space-around; align-items:center;
      padding:12px; background:#fff; border-top:1px solid #ddd; z-index:10;
    }
    .footer img{ width:28px; height:28px; opacity:0.6; transition:opacity .3s; }
    .footer img.active{ opacity:1; }
  </style>
</head>
<body>
  <div class="container">
    <div class="top-bar">
      <div class="close">×</div>
      <div class="top-left"><div class="dot"></div><span>Atualizada em, DD/MM/AAAA às HH:MM</span></div>
      <div class="menu"></div>
    </div>

    <div class="rg-area" id="rgArea">
      <div class="rg-wrapper" id="rgWrapper">
        <img id="rgImg" class="rg-img"
             src="https://rg-app-gov-br.vercel.app/static/base_RGAPP1.png"
             alt="RG Digital" />
      </div>
    </div>

    <div class="footer">
      <img src="https://cdn-icons-png.flaticon.com/512/747/747376.png" alt="Documento" />
      <img src="https://cdn-icons-png.flaticon.com/512/2099/2099058.png" alt="Configurações" />
      <img src="https://cdn-icons-png.flaticon.com/512/1048/1048953.png" class="active" alt="Drone" />
      <img src="https://cdn-icons-png.flaticon.com/512/3524/3524636.png" alt="Opções" />
    </div>
  </div>

  <script>
    (function(){
      const imagens = [
        "https://rg-app-gov-br.vercel.app/static/base_RGAPP1.png",
        "https://rg-app-gov-br.vercel.app/static/base_RGAPP2.png",
        "https://rg-app-gov-br.vercel.app/static/base_RGAPP3.png"
      ];
      let indexAtual = 0;

      const rgArea = document.getElementById('rgArea');
      const rgImg = document.getElementById('rgImg');

      // calcula o tamanho necessário para preencher a área quando a imagem for rotacionada 90 graus
      function ajustarImagemParaArea() {
        const areaW = rgArea.clientWidth;
        const areaH = rgArea.clientHeight;
        const naturalW = rgImg.naturalWidth || rgImg.width;
        const naturalH = rgImg.naturalHeight || rgImg.height;

        if (!areaW || !areaH || !naturalW || !naturalH) {
          return;
        }

        // apos rotacao de 90°:
        const rotatedW = naturalH;
        const rotatedH = naturalW;

        // scale necessário para preencher (cortar o que exceder) => cover behavior
        const scale = Math.max(areaW / rotatedW, areaH / rotatedH);

        // tamanho final (antes da rotação)
        const finalW = Math.round(naturalW * scale);
        const finalH = Math.round(naturalH * scale);

        // aplica largura/altura (essas são as dimensões sem rotação)
        rgImg.style.width = finalW + 'px';
        rgImg.style.height = finalH + 'px';

        // agora centraliza e rotaciona: traduzimos -50% do tamanho atual (já definido) e rotacionamos
        rgImg.style.transform = `translate(-50%, -50%) rotate(90deg)`;
      }

      // trocar imagem e reajustar
      function trocarImagem(novoIndex) {
        indexAtual = novoIndex;
        rgImg.style.opacity = '0';
        rgImg.src = imagens[indexAtual];
      }

      // quando a imagem carregar, ajusta e mostra
      rgImg.onload = function(){
        // timeout pequeno para garantir medidas corretas no WebView
        setTimeout(() => {
          ajustarImagemParaArea();
          rgImg.style.opacity = '1';
        }, 80);
      };

      rgImg.onerror = function(){
        // mostra fallback simples se imagem não carregar
        rgArea.style.background = '#222';
        rgArea.innerHTML = '<div style="color:#fff;padding:20px;text-align:center">Erro ao carregar imagem.</div>';
      };

      // swipes (mobile)
      let startX = 0;
      rgArea.addEventListener('touchstart', function(e){ startX = e.touches[0].clientX; }, {passive:true});
      rgArea.addEventListener('touchend', function(e){
        const endX = e.changedTouches[0].clientX;
        const dx = endX - startX;
        if (Math.abs(dx) > 50) {
          if (dx < 0) indexAtual = (indexAtual + 1) % imagens.length;
          else indexAtual = (indexAtual - 1 + imagens.length) % imagens.length;
          trocarImagem(indexAtual);
        }
      }, {passive:true});

      // reajusta ao redimensionar (ou rotação do device)
      let resizeTimer;
      window.addEventListener('resize', function(){
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(ajustarImagemParaArea, 120);
      });

      // inicializa: força carregamento da imagem atual (caso cache já tenha)
      if (rgImg.complete) {
        setTimeout(() => { ajustarImagemParaArea(); rgImg.style.opacity = '1'; }, 100);
      }
    })();
  </script>
</body>
</html>

